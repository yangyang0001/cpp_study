--------------------------------------------------------------------- 第2章 C++运行实例学习 --------------------------------------------------------------
<< >> 插入运算符

认识std库中的  cin, cout

学习类的相关知识: 类之于对象 就像 类型之于变量。类是一种数据结构, 对象就是某种结构下的实体

--------------------------------------------------------------------- 第3章 基本数据类型 -----------------------------------------------------------------
climits 作为常量引用的库, 这里面定义了很多常量, 可在程序中直接引用, 在文件头引入 #include <climits> 就可以了
sizeof 的使用

#设置打印float和double类型的 小数点的个数
cout.setf(ios_base::fixed, ios_base::floatfield) // fixed-point


--------------------------------------------------------------------- 第4章 组合数据类型 -----------------------------------------------------------------
数组:
    定义格式: type arrayName[arraySize] 的定义格式, 内容存放的数据 可用 = {} 了来定义, 但是数组没有提供直接查询数组长度的方法, 可以用 sizeof(array) / sizeof(array[0])

结构体:
    struct structName { ... }; 推荐使用

共用体:
    union unionName { ... }; 不推荐使用, 在内存字段不为稀缺资源的今天并不推荐使用

指针:
    & 取地址符号; 地址和具体的值是 一个硬币的两面

new 和 delete:
    new 用来分配内存, delete回收内存, new 分配的内存在 (heap) 中或 自由存储空间(free store) 中
    用 new 来创建数组格式: type * pointName = new type[arraySize];
    注意: 当使用完 new 开辟完 heap 内存或 free store 内存后, 必须要用 delete 释放内存, 对于数组来说要用 delete[] 来释放

指针算术:
    指针算术和普通的的运算概念有很大的区别, 指针算术 是针对 每个元素的占用字节进行 移动的! 数组名也是不能够进行加减的因为那是固定的常量, 只能是新的指针变量才能进行指针算术

动态编联和静态编联:
    静态编联 是针对 直接定义数组的编译方式, 在编译期就直接定义好的数据的长度!
    动态编联 是针对 new, new[] 运行时开辟内存的! 需要用 delete 或 delete[] 释放内存!

四种存储方式:
    自动存储, 静态存储, 动态存储, 线程存储

vector 存储在 heap区或free store区, 数组和 array 存放在 stack 区中

vector 定义变量的格式:
vector<typeName> name(ele_num)

--------------------------------------------------------------------- 第5章 循环和关系表达式 --------------------------------------------------------------
打印格式的修改:
    cout.setf(ios_base::boolalpha); 将逻辑表达式表示为 true 或 false

逻辑运算符对string的用法:
    string类型支持 ==、!= 等逻辑运算, 并且实现了值比较

clock:
    clock() 函数的使用, CLOCKS_PER_SEC 每秒系统时间, clock_t 是一种时间类型 这种类型

    // 认识 clock() 函数
    clock_t delay = 10 * 1000;
    clock_t start = clock();
    while(clock() - start < delay) {
    }
    cout << "done" << endl;

    系统时间单位: 提供了一个常量 ctime 中的 CLOCKS_PER_SEC

定义别名, 使用typedef格式如下:
    typedef typeName aliasName

&地址符的灵活应用:
    double scores[5] = {60.0, 70.0, 80.0, 90.0, 100.0};
    for(double &x : scores){
        x = x * 0.80;
    }

cin 的用法和区别:
    char ch;
    cin >> ch; // 会忽略 空格符、换行符、tab符
    cin.get(ch); 或 ch = cin.get(); 不会省略 空格符、换行符、tab符


--------------------------------------------------------------------- 第6章 分支语句和逻辑运算符 ------------------------------------------------
# include <cctype> 具体内部函数的使用, 有个图片可以参考

三目运算符 ? :

switch case 的使用

cin 的使用:
    cin.get(char) cin.getline(char[], arraySize);

IO流模块_文件流 忽略学习 只了解!

cin.get()或 cin.get(ch) 有cin缓冲区 cin.clear() 清除缓存的必要性！

--------------------------------------------------------------------- 第7章 函数 ----------------------------------------------------
C++函数 函数的返回值不能是数组, 这只规定!

函数内部的参数 包括形参, 都称之为局部变量, 也叫自动变量!

存在一级间接关系的 非const 指针或地址 可以 赋值给const指针变量, 禁止使用 多重指针和单重指针的这种赋值操作, 否则编译报错!

string对象就像 处理基本数据类型是一样的, 这里提出了string对象的概念!

函数指针 初步了解
    double pom(int a);      函数指针原型  double (* pf) (int a);


--------------------------------------------------------------------- 第8章 函数探幽 -------------------------------------------------
内联函数: 耗费更多的内存,节省普通函数调用
    格式举例: inline void functionanme(arguments) {...};

引用变量: 指的是给另外一个变量起一个别名, 但这种是地址相同, 大大简化 C中指针的用法, 某个变量的引用! 引用变量用于 结构体和类
    举例: int aa; int & other = aa;

应用变量对于继承的使用, 举例: ofstream ifstream ostream 的使用

默认参数:
    必须从右开始,类似于java中的多个参数占用同一位置的简写方式

函数重载:
    函数重载的重要特征就是参数列表, 这种特征又称为函数特征标或函数签名(function signature), 对于函数重载 函数特征标对于 类型变量和类型引用, 编译器视为一种情况!

函数模板:
    函数泛型或函数模板的使用格式如下: 就和平时定义函数的方式一样, 只是在头部加上一个 template<typename T> 或 template<class T>, 未来使用 typename 关键字,
    如果以后自己编写禁用 class

    函数模板重载的调用优先级: nothing template > concrete template > generic template

    具体化模板和显示实例化的最大差距就是 具体化模板template <> , 而显示实例化没有 <> 只有 template

    具体格式如下:
    template <typename T> void function(T & a); // 泛化模板方法
    template <> void function<int>(int & a);    // 具体化模板方法 [具体化模板 必须依赖于 泛化模板]
    template function<int>(int & a);            // 模板方法实例化

    具体化模板方法 和 模板方法显示实例化 在同一处是互斥的? 为什么互斥?

--------------------------------------------------------------------- 第9章 C++内存模型名称空间 -------------------------------------------------
头文件的引入:
    同一个头文件只能在一个文件中引入一次, 这是C, C++的规范! 防止出现错误的情况, 引入了一下的定义 #if not define , #define , #endif
    #ifndef [if not define]  #define  #endif 来防止 多次引入统一个头文件, 引入头文件用 "", 因为 "" 扫描的范围先从源代码中 再从默认的工具库中获取

    举例: (省略号为结构体的声明, 方法声明, 内联函数等, 一些定义相关的内容)
    #ifndef ABC
    #define ABC
        .....
        .....
        .....
    #endif

-------------------------------------------------------------------------------------------------------------------------
C++存储数据的方式:
    C++的数据存储方式主要区别: 数据保留在内存中的时间
    自动存储: 针对函数的形参和函数内的变量 是自动存储的, 随着方法的执行而创建, 随着方法的结束而释放!          C++有2种变量 属于自动存储!
    静态存储: 函数外部定义的变量或 经过static修饰的变量 都为静态存储模式!                                C++有3种变量 属于静态存储
    动态存储: 使用new开辟内存并用delete释放内存或指导程序结束释放, 这种变量存储称为动态存储或自由存储!      [由new创建, 存放在free store 或 heap中, 由delete释放]
    线程存储: 有thread_local声明的变量就是 线程存储的变量! 其生命周期伴随所属的线程!

    自动存储变量种类: 1、方法中的形参或变量 2、寄存器变量  存储在 stack 中!

    静态存储变量种类: 1、外链静态变量 2、内链静态变量 3、无链静态变量
    1、外链静态变量 必须在代码块外部声明
    2、内链静态变量 必须在代码块外部声明 并 用static修饰
    3、无链静态变量 必须在代码块内部声明 并 用static修饰
-------------------------------------------------------------------------------------------------------------------------
// new 操作运算符 和 delete 操作运算符 的函数模板
void * operator new(size_t);
void * operator new[](size_t);
void operator delete(void *);
void operator delete[](void *);


静态变量的初始化:
    静态初始化: 分为零初始化 和 常量表达式初始化, 二者并成为 静态变量的静态初始化, 时机: 编译器编译时进行初始化
    动态初始化: 编译器编译后的初始化称之为 动态初始化

变量的链接性:
    外部链接性, 内部链接性, 无链接性;
    举例: const在代码块外部定义的变量 属于 内部链接性 静态变量

函数的链接性:
    函数默认的是外部链接性, 但是在函数前用 static 修饰 则函数就变为内部连接性的函数了[注意在声明函数和定义函数的时候都必须要用static修饰]
    内联函数不受单一定义规则限制, 但要求所有的内联函数都是一致的! 外部连接性定义的函数和静态常量都有这种单一定义的规则限制!

C++编译器使用三块内存来存储变量的存储:
    1、自动存储变量区域
    2、静态存储变量区域
    3、动态存储变量区域

常规new函数 和 定义new函数的区别:
    常规new函数 是在heap中开辟内存空间的, 举例: double * pi = new double[4];
    定义new函数 是在指定的地方使用内存的, 举例: double * pi = new (指针或地址) double[4];

    // 常规new函数或常规new运算符 和 定义new函数或定义new运算符
    double * abc = new int;             // invoke new int(sizeof(int));
    double * abc = new int[4];          // invoke new int(4 * sizeof(int));
    double * abc = new (buffer) int;    // invoke new (buffer, sizeof(int));
    double * abc = new (buffer) int[4]; // invoke new (buffer, 4 * sizeof(int));

命名空间: namespace 自定义和使用方式

--------------------------------------------------------------------- 第10章 类和对象 ---------------------------------------------------------
A、首先  了解C++中 封装, 继承, 多态 等一些基础知识

    面向过程编程 和 面向对象编程
        面向过程编程 抽象性并没有那么高, 主要是通过 function 的使用来进行的, C就是面向过程的变成语言, 这种主要编写大量的方法来实现 主要的功能!
        面向对象编程 涉及数据类型并使用数据类型的过程, 抽象出合理的数据类型是非常中要的一个过程!

    类的定义模式:
        class ClazzName {
            private : ....;
            public  : ....;
        };

    // FIXME 在class内部定义的函数将作为 内链函数进行转换, 这块是C++内部的自动转换! 举例以下两者是相同的含义:
    class Stock {
        private : string name;
        private : string pass;
        private : int gender;
        private : int age;

        // class 内部定义的 function, 将自动转换为 内链函数!
        private : void set_name (string n) {
            name = n;
        }
    }

    // FIXME 以上的class声明中 定义的set_name 方法等同于 以下 代码块:
    class Stock {
        private : string name;
        private : string pass;
        private : int gender;
        private : int age;

        private : void set_name (string n);
    }

    inline void Stock::set_name (string n) {
        name = n;
    }

    // TODO 总结: class内部定义的方法, 等同于用声明方法去替代, 然后在类的后面定义这个方法且声明为内链方法!
    // TODO 函数成员的使用, 谁调用类的方法, 方法内部的成员就是谁的, 这和java是一致的!

    类的定义, 实例化 以及使用的过程参考 cpp_study_0002.cpp就OK了!
    类的声明和定义     声明基本(不是所有)用 :    定义基本用 ::, 这是C++区别有别的语言的规则!

B、构造函数 和 析构函数
    构造函数定义: 一般是公共的public: 修饰符 没有返回值类型, 函数名称和类名称相同, 这是构造函数的特征标

    默认构造函数:
        在类没有提供任何构造函数的时候, 编译器会默认提供无参构造函数, 如果已经定义了有参构造函数, 则必须自己定义无参构造函数!

    析构函数:
        假设创建对象 -> 构造函数使用了new分配了内存, 当该对象过期失效时, 程序自动调用析构函数来 delete内存!
        例如类为Stock, 则其析构函数的 为 ~Stock();

    构造函数和析构函数的区别:
        1、构造函数可以有不同的参数, 析构函数没有参数
        2、构造函数没有返回值类型且无前缀表示, 二析构函数要以 ~ 放在类名前面, 举例 Stock 的析构函数格式为 ~Stock();

    TODO 析构函数的调用时机:  参考 cpp_study_0008.cpp文件就OK了, 这块非常重要
        自动存储的类 在执行代码块结束时    自动调用析构函数
        静态存储的类 在程序结束时         自动调用析构函数
        动态存储的类 在主动delete时      主动delete时, 则调用析构函数!
        临时对象存储 在程序结束对象使用时  自动调用析构函数

    常量函数的声明和定义:
        举例:
            void show() const; // 声明

            void Stock:: show() const {

            }

    构造函数: constructor, 析构函数: destructor

C、this指针
    1、定义静态方法的格式 和 java 没有区别 具体格式如下:
       static void mine_show(); 这类函数是没有 this指针的
    2、静态成员函数中没有 this指针, 如果使用则会 error: 'this' is unavailable for static member functions, 再声明一遍 this 是指针!

D、对象数组, 这块创建数组的方式和基本类型创建数组的方式是一样的, 这也符合设计类当初的理念, 将OOP对象设计为和基本类型一样简单的使用方式!

E、类的作用域, 参考java

--------------------------------------------------------------------- 第11章 使用类 ---------------------------------------------------------
重载运算符:
    操作运算符的重载: C++根据不同的操作数的数目和类型来判断 当前的运算符到底有什么作用!
    操作运算符重载格式:  operator op(参数列表), op必须是C++中支持的运算符! 只有这种运算符才能进行重载, 否则不能进行重载!
    注意:
        无论是友元函数还是成员函数,都必须和原始的操作运算符有相同的操作数!
        友元函数和成员函数不能有二义性的定义, 例如T3 = T1 + T2; 那么他的函数原型有以下两种方式[不能同时定义以下的函数原型]:
        Time operator + (const Time & time);
        friend Time operator + (const Time & time1, const Time & time2);

友元:
    友元类, 友元函数, 友元成员函数!
    友元函数:
        1、非类成员函数
        2、声明在类内部 并用 friend 开头, 参数没有隐式声明, 只有显式声明
        3、定义在类的外部 并且 没有friend开头

问题:
    TODO cpp_study_0003.cpp中是类的析构函数的执行时机 和 分析的有出入

--------------------------------------------------------------------- 第12章 类和动态内存分配 ---------------------------------------------------------
类内部的静态变量:
    类实例内部的静态变量是属于类的, 无论有多少个实例共享一个静态变量!
    类中的静态变量是不能在类的定义中进行初始化的, 类的定义只规定了类的内存分配模式, 但没有进行分配内存!

    类的构造函数中如果有new, 则在析构函数中使用delete; 同样如果在构造函数中使用new[], 则在析构函数中使用delete[]

--------------------------------------------------------- 本章核心 start ---------------------------------------------------------
C++中5中特殊的成员函数:
    默认构造函数, 如果没有定义构造函数
    默认析构函数, 如果没有定义析构函数
    复制构造函数
    赋值运算符
    地址运算符

5中特殊成员函数的触发时机是什么?
    1、默认构造函数 触发时机 无参初始化类(不提供显示构造函数的情况下)
    2、默认析构函数 触发时机 类过期时就进行默认析构函数函数的调用(不提供显示析构函数的情况下)
    3、复制构造函数 触发时机 场景:形参为值传递、返回对象的函数使用, 更通俗的理解:当产生对象副本时就会触发复制构造函数
        隐式复制构造函数的功能: 一旦产生已有对象的副本就会触发调用,如果有对象中成员为对象,则同样级连触发该成员变量的隐式复制构造函数, 静态变量除外
        复制构造函数原型:
        ClassName(const ClassName & param);
    4、赋值运算符 触发时机 非初始化对象的赋值操作触发
        赋值运算符触发时机举例:
        StringBad aa;   // none param constructor invoked
        aa = bb;        // assignment operator invoked
        赋值运算符原型:
        ClassName & operator = (const ClassName & param);
    5、地址运算符

复制构造函数和赋值运算符的差别:
    1、触发场景:
        复制构造函数触发场景: 形参 或 返回值类型 均为 对象的情况下! 这种情况下不用关注 当前被赋值对象内部有没有指针类型, 因为是新构造的!
        赋值运算符  触发场景: 非初始化赋值过程

C++中还提供了其他2种特殊的成员函数:
    移动构造函数（move contructor）和移动赋值运算符(move assignment operator)
---------------------------------------------------------  本章核心 end  ---------------------------------------------------------

深度复制和浅复制的区别:
    深度复制: 如果要复制的target对象内部有指针类型的引用, 深度复制要开辟一块新的内存来保存当前指针指向的内容, source对象和target对象完全隔离
    浅度复制: 如果要复制的target对象内部有指针类型的引用, 浅度复制直接使用这个指针就OK了, 不用关注指针指向的内容


C++中的空指针的表示方式有以下两种, 用0 或 nullptr, 后者为推荐使用方式!
    举例:
    string aa = 0;
    string bb = nullptr;

静态成员函数:
    如果声明和定义是分开的, 则在定义的时候一定不能加static, 静态成员函数内部不能使用this指针, 因为成员函数不属于某个实例而属于类调用方式为 ClassName:: methodName()

在构造函数中使用new要注意的事项:
    1、如果在对象中使用的构造函数使用new, 那么对应的析构函数中要使用delete, 如果使用new[] 则在析构函数中使用 delete[]
    2、如果存在多个构造函数, 内部使用的new 或 new[] 必须统一, 使用new 则都使用new; 如果使用new[] 则都是用new[], 因为只有一个析构函数进行内存的回收, 所以必须要统一创建规则

类成员为类的时候, 类成员逐个复制的问题 举例:
    class Magazine {
        private:
            String title;
            String publisher;
    }
    如果是 Magazine来进行复制或赋值, 则默认调用String的复制构造函数和赋值运算符, 这里有些自动的感觉!
    [TODO 为什么有自动的感觉, 难道是Magazine的默认复制构造函数和赋值运算符已经默认调用了String类的复制构造函数和赋值运算符了?]

    如果 Magazine类其他属性需要定义默认构造函数和赋值运算符 则需要显示调用String的默认构造函数和赋值运算符, 这种情况将变得极其复杂在第13章会进一步讲解这块的东西!

有关返回对象的说明:
    返回对象的三种方式   对象引用, const对象引用, const对象



























